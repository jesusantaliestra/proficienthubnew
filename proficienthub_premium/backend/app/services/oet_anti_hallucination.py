"""
OET Anti-Hallucination Validation System
=========================================
Multi-layer validation to ensure generated OET content is:
- Medically accurate and appropriate
- Free from AI artifacts and placeholders
- Compliant with official OET format
- Profession-specific and relevant
"""

import re
from enum import Enum
from typing import Dict, List, Optional, Tuple, Set, Any
from dataclasses import dataclass, field
from datetime import datetime

from ..content.oet_specifications import (
    OETHealthcareProfession,
    OETSection,
    OET_PROFESSION_CONTEXTS,
    OET_EXAM_SPEC
)


class ValidationSeverity(str, Enum):
    """Severity levels for validation issues"""
    CRITICAL = "critical"      # Must regenerate
    HIGH = "high"              # Needs manual review
    MEDIUM = "medium"          # Should fix but acceptable
    LOW = "low"                # Minor suggestion


class ValidationResult(str, Enum):
    """Final validation result"""
    PASSED = "passed"                    # Score >= 0.85
    NEEDS_REVIEW = "needs_review"        # Score 0.65-0.84
    FAILED = "failed"                    # Score 0.40-0.64
    REGENERATE = "regenerate"            # Score < 0.40 or critical issues


@dataclass
class ValidationIssue:
    """Individual validation issue"""
    code: str
    message: str
    severity: ValidationSeverity
    location: Optional[str] = None
    suggestion: Optional[str] = None


@dataclass
class ValidationReport:
    """Complete validation report for generated content"""
    result: ValidationResult
    score: float
    issues: List[ValidationIssue] = field(default_factory=list)
    passed_checks: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.utcnow)

    @property
    def critical_issues(self) -> List[ValidationIssue]:
        return [i for i in self.issues if i.severity == ValidationSeverity.CRITICAL]

    @property
    def high_issues(self) -> List[ValidationIssue]:
        return [i for i in self.issues if i.severity == ValidationSeverity.HIGH]


class OETAntiHallucinationValidator:
    """
    Multi-layer validation system for OET exam content.

    Validation Layers:
    1. Forbidden Patterns - Detect AI artifacts
    2. Healthcare Terminology - Validate medical terms
    3. Format Compliance - Check OET structure
    4. Content Authenticity - Ensure realistic scenarios
    5. Profession Specificity - Match profession context
    """

    # ============================================================
    # LAYER 1: FORBIDDEN PATTERNS (AI Artifacts Detection)
    # ============================================================

    FORBIDDEN_PATTERNS: Dict[str, List[str]] = {
        "ai_references": [
            r"\bAI\b", r"\bartificial intelligence\b",
            r"\blanguage model\b", r"\bGPT\b", r"\bClaude\b",
            r"\bChatGPT\b", r"\bas an AI\b", r"\bI am a\b.*\bmodel\b",
            r"\bgenerated by\b", r"\bautomatically created\b"
        ],
        "placeholder_text": [
            r"\[.*?\]",                              # [placeholder]
            r"\{.*?\}",                              # {variable}
            r"<.*?>",                                # <insert here>
            r"PLACEHOLDER",
            r"INSERT_HERE",
            r"TODO",
            r"FIXME",
            r"XXX",
            r"Lorem ipsum",
            r"Sample text",
            r"Example here",
            r"Your.*?here",
            r"___+",                                 # Blanks
        ],
        "meta_instructions": [
            r"write a\b.*\bletter",
            r"generate\b.*\bcontent",
            r"create a\b.*\bscenario",
            r"following is\b.*\bexample",
            r"this is a\b.*\bsample",
            r"note:.*?(instruction|guideline)",
            r"remember to\b",
            r"don't forget\b",
            r"make sure\b.*\binclude",
        ],
        "fake_names_patterns": [
            r"\bJohn Doe\b",
            r"\bJane Doe\b",
            r"\bJohn Smith\b",
            r"\bPatient X\b",
            r"\bMr\. X\b",
            r"\bMrs\. X\b",
            r"\bDoctor X\b",
            r"\bNurse X\b",
            r"\bTest Patient\b",
            r"\bSample Patient\b",
        ],
        "unrealistic_values": [
            r"blood pressure.*?(\d{4}|\d/\d\d\d)",   # Impossible BP
            r"temperature.*?(50|60|70)\s*°?C",       # Impossible temp
            r"heart rate.*?(\d{4})",                 # Impossible HR
            r"age.*?(150|200|300)",                  # Impossible age
            r"weight.*?(500|600)\s*kg",              # Impossible weight
        ]
    }

    # ============================================================
    # LAYER 2: HEALTHCARE TERMINOLOGY VALIDATION
    # ============================================================

    # Commonly misspelled medical terms (correct: wrong_variants)
    MEDICAL_SPELLING: Dict[str, List[str]] = {
        "diarrhoea": ["diarhea", "diarrea", "diarea"],
        "haemorrhage": ["hemorrage", "hemmorhage"],
        "oedema": ["edema"],  # UK vs US - OET uses UK
        "anaemia": ["anemia"],  # UK vs US - OET uses UK
        "paediatric": ["pediatric"],  # UK vs US - OET uses UK
        "caesarean": ["cesarean", "cesarian"],
        "oesophagus": ["esophagus"],  # UK vs US - OET uses UK
        "foetus": ["fetus"],  # UK vs US - OET uses UK
        "gynaecology": ["gynecology"],  # UK vs US - OET uses UK
        "haematology": ["hematology"],  # UK vs US - OET uses UK
        "orthopaedic": ["orthopedic"],  # UK vs US - OET uses UK
        "litre": ["liter"],  # UK spelling
        "metre": ["meter"],  # UK spelling
        "cancelled": ["canceled"],  # UK spelling
        "behaviour": ["behavior"],  # UK spelling
        "colour": ["color"],  # UK spelling
        "favourable": ["favorable"],  # UK spelling
        "programme": ["program"],  # UK spelling (for treatment programmes)
    }

    # Valid vital signs ranges
    VITAL_SIGN_RANGES: Dict[str, Tuple[float, float]] = {
        "temperature_celsius": (35.0, 42.0),
        "heart_rate_bpm": (40, 200),
        "systolic_bp": (70, 250),
        "diastolic_bp": (40, 150),
        "respiratory_rate": (8, 40),
        "oxygen_saturation": (70, 100),
        "bmi": (12, 60),
        "blood_glucose_mmol": (2.0, 30.0),
    }

    # Healthcare terminology that MUST be present (per section type)
    REQUIRED_HEALTHCARE_MARKERS: Dict[str, List[str]] = {
        "consultation": [
            r"\b(patient|client)\b",
            r"\b(symptoms?|complaints?|presenting|history)\b",
            r"\b(examination|assessment|diagnosis|treatment)\b",
        ],
        "referral_letter": [
            r"\b(refer|referral|referring)\b",
            r"\b(patient|client)\b",
            r"\b(assessment|review|consultation|opinion)\b",
            r"\b(history|presentation|symptoms?)\b",
        ],
        "discharge_letter": [
            r"\b(discharg|admission|admitted)\b",
            r"\b(patient|client)\b",
            r"\b(treatment|management|medication)\b",
            r"\b(follow[- ]?up|review|appointment)\b",
        ],
    }

    # ============================================================
    # LAYER 3: FORMAT COMPLIANCE VALIDATION
    # ============================================================

    # Writing letter required components
    LETTER_REQUIRED_COMPONENTS: List[str] = [
        "date",
        "recipient_salutation",
        "patient_identification",
        "purpose_statement",
        "closing",
    ]

    # Listening question format patterns
    LISTENING_FORMATS: Dict[str, Dict[str, Any]] = {
        "part_a": {
            "question_type": "note_completion",
            "max_words": 3,
            "answer_pattern": r"^[\w\s\-\/]+$",
        },
        "part_b": {
            "question_type": "multiple_choice",
            "options": ["A", "B", "C"],
            "answer_pattern": r"^[ABC]$",
        },
        "part_c": {
            "question_type": "multiple_choice",
            "options": ["A", "B", "C", "D"],
            "answer_pattern": r"^[ABCD]$",
        },
    }

    # Reading question format patterns
    READING_FORMATS: Dict[str, Dict[str, Any]] = {
        "part_a": {
            "question_types": ["matching", "sentence_completion"],
            "time_pressure": True,
            "texts_count": 4,
        },
        "part_b": {
            "question_types": ["multiple_choice", "matching", "short_answer"],
            "texts_count": 2,
        },
    }

    # ============================================================
    # LAYER 4: CONTENT AUTHENTICITY VALIDATION
    # ============================================================

    # Realistic patient age ranges by condition category
    CONDITION_AGE_RANGES: Dict[str, Tuple[int, int]] = {
        "paediatric": (0, 18),
        "adult_general": (18, 65),
        "geriatric": (65, 100),
        "obstetric": (16, 50),
        "neonatal": (0, 1),
    }

    # Prohibited unrealistic scenario elements
    UNREALISTIC_SCENARIOS: List[str] = [
        r"miracle\s+cure",
        r"100%\s+(effective|guaranteed|success)",
        r"instant(ly)?\s+(heal|cure|recover)",
        r"no\s+side\s+effects",
        r"revolutionary\s+treatment",
        r"secret\s+(remedy|cure|treatment)",
        r"alternative\s+medicine\s+only",
    ]

    # ============================================================
    # LAYER 5: PROFESSION SPECIFICITY VALIDATION
    # ============================================================

    def __init__(self):
        self._compile_patterns()

    def _compile_patterns(self):
        """Pre-compile regex patterns for performance"""
        self._forbidden_compiled = {}
        for category, patterns in self.FORBIDDEN_PATTERNS.items():
            self._forbidden_compiled[category] = [
                re.compile(p, re.IGNORECASE) for p in patterns
            ]

        self._unrealistic_compiled = [
            re.compile(p, re.IGNORECASE) for p in self.UNREALISTIC_SCENARIOS
        ]

    # ============================================================
    # VALIDATION METHODS
    # ============================================================

    def validate_content(
        self,
        content: str,
        section: OETSection,
        profession: OETHealthcareProfession,
        content_type: Optional[str] = None,
    ) -> ValidationReport:
        """
        Main validation entry point.

        Args:
            content: The generated content to validate
            section: OET section (listening/reading/writing/speaking)
            profession: Healthcare profession
            content_type: Optional specific type (e.g., "referral_letter")

        Returns:
            ValidationReport with result, score, and issues
        """
        issues: List[ValidationIssue] = []
        passed_checks: List[str] = []

        # Layer 1: Forbidden patterns
        layer1_issues = self._check_forbidden_patterns(content)
        issues.extend(layer1_issues)
        if not layer1_issues:
            passed_checks.append("forbidden_patterns")

        # Layer 2: Healthcare terminology
        layer2_issues = self._check_healthcare_terminology(content, section)
        issues.extend(layer2_issues)
        if not layer2_issues:
            passed_checks.append("healthcare_terminology")

        # Layer 3: Format compliance
        layer3_issues = self._check_format_compliance(content, section, content_type)
        issues.extend(layer3_issues)
        if not layer3_issues:
            passed_checks.append("format_compliance")

        # Layer 4: Content authenticity
        layer4_issues = self._check_content_authenticity(content)
        issues.extend(layer4_issues)
        if not layer4_issues:
            passed_checks.append("content_authenticity")

        # Layer 5: Profession specificity
        layer5_issues = self._check_profession_specificity(content, profession)
        issues.extend(layer5_issues)
        if not layer5_issues:
            passed_checks.append("profession_specificity")

        # Calculate score and result
        score = self._calculate_score(issues)
        result = self._determine_result(score, issues)

        return ValidationReport(
            result=result,
            score=score,
            issues=issues,
            passed_checks=passed_checks,
            metadata={
                "section": section.value,
                "profession": profession.value,
                "content_type": content_type,
                "content_length": len(content),
            }
        )

    def _check_forbidden_patterns(self, content: str) -> List[ValidationIssue]:
        """Layer 1: Check for AI artifacts and forbidden patterns"""
        issues = []

        for category, patterns in self._forbidden_compiled.items():
            for pattern in patterns:
                matches = pattern.findall(content)
                if matches:
                    severity = (
                        ValidationSeverity.CRITICAL
                        if category in ["ai_references", "meta_instructions"]
                        else ValidationSeverity.HIGH
                    )
                    issues.append(ValidationIssue(
                        code=f"FORBIDDEN_{category.upper()}",
                        message=f"Found forbidden pattern: {matches[0]}",
                        severity=severity,
                        location=f"Pattern: {pattern.pattern}",
                        suggestion="Remove or replace with authentic content"
                    ))

        return issues

    def _check_healthcare_terminology(
        self, content: str, section: OETSection
    ) -> List[ValidationIssue]:
        """Layer 2: Validate healthcare terminology"""
        issues = []

        # Check for US spellings (OET uses UK English)
        for correct, wrong_variants in self.MEDICAL_SPELLING.items():
            for wrong in wrong_variants:
                if re.search(rf"\b{wrong}\b", content, re.IGNORECASE):
                    issues.append(ValidationIssue(
                        code="US_SPELLING",
                        message=f"US spelling '{wrong}' found - OET uses UK English",
                        severity=ValidationSeverity.MEDIUM,
                        suggestion=f"Use UK spelling: '{correct}'"
                    ))

        # Check vital signs are within realistic ranges
        vital_patterns = {
            "temperature_celsius": r"(\d+\.?\d*)\s*°?\s*C",
            "heart_rate_bpm": r"(?:heart rate|HR|pulse)[:\s]+(\d+)",
            "systolic_bp": r"(?:BP|blood pressure)[:\s]+(\d+)/",
            "diastolic_bp": r"(?:BP|blood pressure)[:\s]+\d+/(\d+)",
            "oxygen_saturation": r"(?:SpO2|O2 sat|saturation)[:\s]+(\d+)",
            "respiratory_rate": r"(?:RR|respiratory rate)[:\s]+(\d+)",
        }

        for vital, pattern in vital_patterns.items():
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                value = float(match.group(1))
                min_val, max_val = self.VITAL_SIGN_RANGES.get(vital, (0, 1000))
                if not (min_val <= value <= max_val):
                    issues.append(ValidationIssue(
                        code="INVALID_VITAL_SIGN",
                        message=f"Unrealistic {vital}: {value} (valid range: {min_val}-{max_val})",
                        severity=ValidationSeverity.CRITICAL,
                        suggestion=f"Use realistic value between {min_val} and {max_val}"
                    ))

        return issues

    def _check_format_compliance(
        self,
        content: str,
        section: OETSection,
        content_type: Optional[str]
    ) -> List[ValidationIssue]:
        """Layer 3: Check OET format compliance"""
        issues = []

        if section == OETSection.WRITING:
            issues.extend(self._validate_letter_format(content, content_type))
        elif section == OETSection.LISTENING:
            issues.extend(self._validate_listening_format(content, content_type))
        elif section == OETSection.READING:
            issues.extend(self._validate_reading_format(content, content_type))
        elif section == OETSection.SPEAKING:
            issues.extend(self._validate_speaking_format(content, content_type))

        return issues

    def _validate_letter_format(
        self, content: str, letter_type: Optional[str]
    ) -> List[ValidationIssue]:
        """Validate OET writing letter format"""
        issues = []

        # Check word count (180-200 words)
        word_count = len(content.split())
        if word_count < 170:
            issues.append(ValidationIssue(
                code="LETTER_TOO_SHORT",
                message=f"Letter has {word_count} words (minimum ~180)",
                severity=ValidationSeverity.HIGH,
                suggestion="Expand content to meet minimum word count"
            ))
        elif word_count > 220:
            issues.append(ValidationIssue(
                code="LETTER_TOO_LONG",
                message=f"Letter has {word_count} words (target ~200)",
                severity=ValidationSeverity.MEDIUM,
                suggestion="Reduce content - OET letters should be concise"
            ))

        # Check for date
        date_patterns = [
            r"\d{1,2}[/\-\.]\d{1,2}[/\-\.]\d{2,4}",
            r"\d{1,2}\s+(January|February|March|April|May|June|July|August|September|October|November|December)",
        ]
        has_date = any(re.search(p, content, re.IGNORECASE) for p in date_patterns)
        if not has_date:
            issues.append(ValidationIssue(
                code="MISSING_DATE",
                message="Letter missing date",
                severity=ValidationSeverity.HIGH,
                suggestion="Add date at the beginning of the letter"
            ))

        # Check for salutation
        salutation_patterns = [
            r"Dear\s+(Dr\.?|Mr\.?|Mrs\.?|Ms\.?|Professor)",
            r"Dear\s+Colleague",
            r"Dear\s+Sir/Madam",
        ]
        has_salutation = any(re.search(p, content) for p in salutation_patterns)
        if not has_salutation:
            issues.append(ValidationIssue(
                code="MISSING_SALUTATION",
                message="Letter missing proper salutation",
                severity=ValidationSeverity.HIGH,
                suggestion="Add 'Dear Dr. [Name]' or appropriate salutation"
            ))

        # Check for patient identification (Re: line)
        if not re.search(r"Re:\s*", content):
            issues.append(ValidationIssue(
                code="MISSING_RE_LINE",
                message="Letter missing 'Re:' patient identification line",
                severity=ValidationSeverity.HIGH,
                suggestion="Add 'Re: [Patient Name], DOB: [Date]' line"
            ))

        # Check for closing
        closing_patterns = [
            r"Yours\s+(sincerely|faithfully)",
            r"Kind\s+regards",
            r"Best\s+regards",
        ]
        has_closing = any(re.search(p, content, re.IGNORECASE) for p in closing_patterns)
        if not has_closing:
            issues.append(ValidationIssue(
                code="MISSING_CLOSING",
                message="Letter missing proper closing",
                severity=ValidationSeverity.MEDIUM,
                suggestion="Add 'Yours sincerely' or 'Kind regards'"
            ))

        # Check letter type specific requirements
        if letter_type == "referral":
            if not re.search(r"(refer|appreciate.*?(see|assess|review))", content, re.IGNORECASE):
                issues.append(ValidationIssue(
                    code="REFERRAL_PURPOSE_UNCLEAR",
                    message="Referral letter doesn't clearly state referral purpose",
                    severity=ValidationSeverity.HIGH,
                    suggestion="Clearly state why you are referring the patient"
                ))

        elif letter_type == "discharge":
            if not re.search(r"(discharg|admitted|admission)", content, re.IGNORECASE):
                issues.append(ValidationIssue(
                    code="DISCHARGE_CONTEXT_MISSING",
                    message="Discharge letter doesn't mention admission/discharge context",
                    severity=ValidationSeverity.HIGH,
                    suggestion="Include admission date and discharge details"
                ))

        return issues

    def _validate_listening_format(
        self, content: str, part: Optional[str]
    ) -> List[ValidationIssue]:
        """Validate OET listening content format"""
        issues = []

        # Check for healthcare context markers
        healthcare_markers = [
            r"\b(patient|doctor|nurse|clinic|hospital|medication|treatment)\b"
        ]
        if not any(re.search(p, content, re.IGNORECASE) for p in healthcare_markers):
            issues.append(ValidationIssue(
                code="MISSING_HEALTHCARE_CONTEXT",
                message="Listening content lacks healthcare context",
                severity=ValidationSeverity.HIGH,
                suggestion="Ensure content is set in healthcare environment"
            ))

        return issues

    def _validate_reading_format(
        self, content: str, part: Optional[str]
    ) -> List[ValidationIssue]:
        """Validate OET reading content format"""
        issues = []

        # Check text length
        word_count = len(content.split())

        if part == "part_a":
            # Part A texts should be 550-700 words each
            if word_count < 500:
                issues.append(ValidationIssue(
                    code="READING_TEXT_TOO_SHORT",
                    message=f"Reading text has {word_count} words (Part A needs 550-700)",
                    severity=ValidationSeverity.HIGH,
                    suggestion="Expand text to appropriate length"
                ))
        elif part == "part_b":
            # Part B texts should be 500-800 words each
            if word_count < 450:
                issues.append(ValidationIssue(
                    code="READING_TEXT_TOO_SHORT",
                    message=f"Reading text has {word_count} words (Part B needs 500-800)",
                    severity=ValidationSeverity.HIGH,
                    suggestion="Expand text to appropriate length"
                ))

        return issues

    def _validate_speaking_format(
        self, content: str, scenario_type: Optional[str]
    ) -> List[ValidationIssue]:
        """Validate OET speaking roleplay format"""
        issues = []

        # Check for roleplay structure elements
        if "SETTING:" not in content.upper() and "Setting:" not in content:
            issues.append(ValidationIssue(
                code="MISSING_SETTING",
                message="Speaking roleplay missing setting description",
                severity=ValidationSeverity.MEDIUM,
                suggestion="Add 'Setting:' section describing the scenario location"
            ))

        if "PATIENT" not in content.upper() and "CANDIDATE" not in content.upper():
            issues.append(ValidationIssue(
                code="MISSING_ROLE_CARDS",
                message="Speaking roleplay missing patient/candidate role cards",
                severity=ValidationSeverity.HIGH,
                suggestion="Include separate cards for patient and candidate roles"
            ))

        return issues

    def _check_content_authenticity(self, content: str) -> List[ValidationIssue]:
        """Layer 4: Check for unrealistic content"""
        issues = []

        # Check for unrealistic scenario elements
        for pattern in self._unrealistic_compiled:
            if pattern.search(content):
                issues.append(ValidationIssue(
                    code="UNREALISTIC_SCENARIO",
                    message=f"Unrealistic claim found: {pattern.pattern}",
                    severity=ValidationSeverity.HIGH,
                    suggestion="Use evidence-based, realistic medical scenarios"
                ))

        # Check for overly dramatic language
        dramatic_patterns = [
            r"life-threatening emergency",
            r"critical condition",
            r"near death",
        ]
        dramatic_count = sum(
            1 for p in dramatic_patterns if re.search(p, content, re.IGNORECASE)
        )
        if dramatic_count > 1:
            issues.append(ValidationIssue(
                code="OVERLY_DRAMATIC",
                message="Content uses excessive dramatic language",
                severity=ValidationSeverity.LOW,
                suggestion="Use measured, professional clinical language"
            ))

        return issues

    def _check_profession_specificity(
        self, content: str, profession: OETHealthcareProfession
    ) -> List[ValidationIssue]:
        """Layer 5: Validate profession-specific content"""
        issues = []

        context = OET_PROFESSION_CONTEXTS.get(profession)
        if not context:
            return issues

        # Check for at least some profession-specific terminology
        terminology_found = 0
        for term in context.key_terminology[:10]:  # Check first 10 terms
            term_pattern = term.replace("_", r"[\s\-_]?")
            if re.search(rf"\b{term_pattern}\b", content, re.IGNORECASE):
                terminology_found += 1

        if terminology_found == 0:
            issues.append(ValidationIssue(
                code="MISSING_PROFESSION_TERMINOLOGY",
                message=f"Content lacks {profession.value}-specific terminology",
                severity=ValidationSeverity.MEDIUM,
                suggestion=f"Include relevant {profession.value} terminology"
            ))

        # Check that content doesn't use wrong profession terminology
        other_profession_markers = {
            OETHealthcareProfession.DENTISTRY: ["tooth", "dental", "oral"],
            OETHealthcareProfession.VETERINARY_SCIENCE: ["animal", "pet", "veterinary"],
            OETHealthcareProfession.OPTOMETRY: ["eye", "vision", "optical"],
        }

        for other_prof, markers in other_profession_markers.items():
            if other_prof != profession:
                for marker in markers:
                    # Only flag if this marker is central to content
                    if content.lower().count(marker) > 3:
                        issues.append(ValidationIssue(
                            code="WRONG_PROFESSION_CONTEXT",
                            message=f"Content appears to be for {other_prof.value}, not {profession.value}",
                            severity=ValidationSeverity.HIGH,
                            suggestion=f"Generate content specific to {profession.value}"
                        ))
                        break

        return issues

    def _calculate_score(self, issues: List[ValidationIssue]) -> float:
        """Calculate validation score based on issues"""
        if not issues:
            return 1.0

        # Severity weights
        weights = {
            ValidationSeverity.CRITICAL: 0.30,
            ValidationSeverity.HIGH: 0.15,
            ValidationSeverity.MEDIUM: 0.08,
            ValidationSeverity.LOW: 0.03,
        }

        total_penalty = sum(weights[issue.severity] for issue in issues)
        score = max(0.0, 1.0 - total_penalty)

        return round(score, 2)

    def _determine_result(
        self, score: float, issues: List[ValidationIssue]
    ) -> ValidationResult:
        """Determine final validation result"""
        # Critical issues always trigger regeneration
        if any(i.severity == ValidationSeverity.CRITICAL for i in issues):
            return ValidationResult.REGENERATE

        if score >= 0.85:
            return ValidationResult.PASSED
        elif score >= 0.65:
            return ValidationResult.NEEDS_REVIEW
        elif score >= 0.40:
            return ValidationResult.FAILED
        else:
            return ValidationResult.REGENERATE


# ============================================================
# SPECIALIZED VALIDATORS
# ============================================================

class OETWritingValidator(OETAntiHallucinationValidator):
    """Specialized validator for OET Writing section"""

    def validate_letter(
        self,
        letter_content: str,
        case_notes: str,
        profession: OETHealthcareProfession,
        letter_type: str,
    ) -> ValidationReport:
        """Validate a generated OET writing letter against case notes"""
        report = self.validate_content(
            content=letter_content,
            section=OETSection.WRITING,
            profession=profession,
            content_type=letter_type,
        )

        # Additional: Check case notes are reflected in letter
        case_note_issues = self._validate_case_note_coverage(
            letter_content, case_notes
        )
        report.issues.extend(case_note_issues)

        # Recalculate score
        report.score = self._calculate_score(report.issues)
        report.result = self._determine_result(report.score, report.issues)

        return report

    def _validate_case_note_coverage(
        self, letter: str, case_notes: str
    ) -> List[ValidationIssue]:
        """Check that key case note information is in the letter"""
        issues = []

        # Extract key entities from case notes
        # Patient name pattern
        name_match = re.search(
            r"(?:Name|Patient)[:\s]+([A-Z][a-z]+\s+[A-Z][a-z]+)",
            case_notes
        )
        if name_match:
            patient_name = name_match.group(1)
            if patient_name.lower() not in letter.lower():
                issues.append(ValidationIssue(
                    code="PATIENT_NAME_MISSING",
                    message=f"Patient name '{patient_name}' from case notes not in letter",
                    severity=ValidationSeverity.HIGH,
                    suggestion="Include patient's name from case notes"
                ))

        # DOB pattern
        dob_match = re.search(
            r"(?:DOB|Date of Birth)[:\s]+(\d{1,2}[/\-\.]\d{1,2}[/\-\.]\d{2,4})",
            case_notes
        )
        if dob_match:
            dob = dob_match.group(1)
            if dob not in letter:
                issues.append(ValidationIssue(
                    code="DOB_MISSING",
                    message="Patient DOB from case notes not in letter",
                    severity=ValidationSeverity.MEDIUM,
                    suggestion="Include patient's date of birth"
                ))

        # Diagnosis/presenting complaint
        diagnosis_patterns = [
            r"(?:Diagnosis|Presenting complaint)[:\s]+([^\n]+)",
            r"(?:Admitted with|Presented with)[:\s]+([^\n]+)",
        ]
        for pattern in diagnosis_patterns:
            diag_match = re.search(pattern, case_notes, re.IGNORECASE)
            if diag_match:
                diagnosis_terms = diag_match.group(1).split()[:3]
                found = any(
                    term.lower() in letter.lower()
                    for term in diagnosis_terms
                    if len(term) > 3
                )
                if not found:
                    issues.append(ValidationIssue(
                        code="DIAGNOSIS_NOT_ADDRESSED",
                        message="Main diagnosis from case notes not mentioned in letter",
                        severity=ValidationSeverity.HIGH,
                        suggestion="Address the primary diagnosis/presenting complaint"
                    ))
                break

        return issues


class OETSpeakingValidator(OETAntiHallucinationValidator):
    """Specialized validator for OET Speaking section"""

    def validate_roleplay(
        self,
        candidate_card: str,
        patient_card: str,
        profession: OETHealthcareProfession,
        scenario_type: str,
    ) -> ValidationReport:
        """Validate OET speaking roleplay cards"""
        combined_content = f"{candidate_card}\n\n{patient_card}"

        report = self.validate_content(
            content=combined_content,
            section=OETSection.SPEAKING,
            profession=profession,
            content_type=scenario_type,
        )

        # Additional roleplay-specific validation
        roleplay_issues = self._validate_roleplay_structure(
            candidate_card, patient_card
        )
        report.issues.extend(roleplay_issues)

        # Recalculate
        report.score = self._calculate_score(report.issues)
        report.result = self._determine_result(report.score, report.issues)

        return report

    def _validate_roleplay_structure(
        self, candidate_card: str, patient_card: str
    ) -> List[ValidationIssue]:
        """Validate roleplay card structure"""
        issues = []

        # Candidate card should have tasks
        task_patterns = [r"•", r"\d\.", r"-\s+[A-Z]"]
        if not any(re.search(p, candidate_card) for p in task_patterns):
            issues.append(ValidationIssue(
                code="CANDIDATE_TASKS_MISSING",
                message="Candidate card missing clear task bullets",
                severity=ValidationSeverity.HIGH,
                suggestion="Add numbered or bulleted tasks for candidate"
            ))

        # Patient card should have concerns/information to share
        if len(patient_card.split()) < 50:
            issues.append(ValidationIssue(
                code="PATIENT_CARD_SPARSE",
                message="Patient card lacks sufficient detail",
                severity=ValidationSeverity.MEDIUM,
                suggestion="Add more patient background and concerns"
            ))

        return issues


# Singleton instances
oet_validator = OETAntiHallucinationValidator()
oet_writing_validator = OETWritingValidator()
oet_speaking_validator = OETSpeakingValidator()
